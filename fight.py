# Задание: Применение Принципа Открытости/Закрытости (Open/Closed Principle) в Разработке Простой Игры
# Цель: Цель этого домашнего задание - закрепить понимание и навыки применения принципа открытости/закрытости
# (Open/Closed Principle), одного из пяти SOLID принципов объектно-ориентированного программирования.
# Принцип гласит, что программные сущности (классы, модули, функции и т.д.) должны быть открыты для
# расширения, но закрыты для модификации.
# Задача: Разработать простую игру, где игрок может использовать различные типы оружия для борьбы с монстрами.
# Программа должна быть спроектирована таким образом, чтобы легко можно было добавлять новые типы оружия,
# не изменяя существующий код бойцов или механизм боя.
# Исходные данные:
# Есть класс Fighter, представляющий бойца.
# Есть класс Monster, представляющий монстра.
# Игрок управляет бойцом и может выбирать для него одно из вооружений для боя.
# Шаг 1: Создайте абстрактный класс для оружия
# Создайте абстрактный класс Weapon, который будет содержать абстрактный метод attack().
# Шаг 2: Реализуйте конкретные типы оружия
# Создайте несколько классов, унаследованных от Weapon, например, Sword и Bow. Каждый из этих классов реализует
# метод attack() своим уникальным способом.
# Шаг 3: Модифицируйте класс Fighter
# Добавьте в класс Fighter поле, которое будет хранить объект класса Weapon.
# Добавьте метод changeWeapon(), который позволяет изменить оружие бойца.
# Шаг 4: Реализация боя
# Реализуйте простой механизм для демонстрации боя между бойцом и монстром, исходя из выбранного оружия.
# Требования к заданию:
# Код должен быть написан на Python.
# Программа должна демонстрировать применение принципа открытости/закрытости: новые типы оружия можно легко
# добавлять, не изменяя существующие классы бойцов и механизм боя.
# Программа должна выводить результат боя в консоль.
# Пример результата:
# Боец выбирает меч.
# Боец наносит удар мечом.
# Монстр побежден!
# Боец выбирает лук.
# Боец наносит удар из лука.
# Монстр побежден!

from abc import ABC, abstractmethod
import random, time

# Класс описывающий 1-го персонажа
class Fighter():
    def __init__(self):
        self.weapon = None                              # Текущее оружие персонажа
        self.name = "Боец"                              # Имя персонажа

    def changeWeapon(self, new_weapon):                 # Смена оружия у персонажа
        self.weapon = new_weapon
        print(f"Боец выбрал {self.weapon.name}")

# Класс описывающий 2-го персонажа
class Monster():
    def __init__(self):
        self.weapon = None                              # Текущее оружие персонажа
        self.name = "Монстр"                            # Имя персонажа

    def changeWeapon(self, new_weapon):                 # Смена оружия у персонажа
        self.weapon = new_weapon
        print(f"Монстр выбрал {self.weapon.name}")

# Абстрактный базовый класс для видов оружия
class Weapon(ABC):
    @abstractmethod
    def attack(self):                                   # Абстрактная функция применения оружия
        pass
# Производный класс вида оружия
class Sword(Weapon):
    def __init__(self):
        self.effect = 1                                 # Эффективность применения данного вида оружия
        self.name = "меч"                               # Наименование данного вида оружия

    def attack(self, person):                           # Переопределенная функция применения данного вида оружия
        print(f"{person} наносит удар мечом")

# Производный класс вида оружия
class Bow(Weapon):
    def __init__(self):
        self.effect = 2                                 # Эффективность применения данного вида оружия
        self.name = "лук"                               # Наименование данного вида оружия

    def attack(self, person):                           # Переопределенная функция применения данного вида оружия
        print(f"{person} пускает стрелу из лука")

# Производный класс вида оружия
class Shield(Weapon):
    def __init__(self):
        self.effect = 1                                 # Эффективность применения данного вида оружия
        self.name = "щит"                               # Наименование данного вида оружия

    def attack(self, person):                           # Переопределенная функция применения данного вида оружия
        print(f"{person} защищается щитом")

# Производный класс вида оружия
class Gun(Weapon):
    def __init__(self):
        self.effect = 3                                 # Эффективность применения данного вида оружия
        self.name = "пищаль"                            # Наименование данного вида оружия

    def attack(self, person):                           # Переопределенная функция применения данного вида оружия
        print(f"{person} стреляет из пищали")

# Реализация боя

# Создание объектов персонажей
fighter = Fighter()
monster = Monster()

weapon_list = [Sword(), Bow(), Shield(), Gun()]         # Создание списка видов оружия. При добавлении нового вида требует корректировки

while True:                                             # Цикл схваток
    # Выбор оружия для каждого персонажа
    weapon_f = random.choice(weapon_list)
    fighter.changeWeapon(weapon_f)
    weapon_m = random.choice(weapon_list)
    monster.changeWeapon(weapon_m)

    # Применение оружия персонажами
    weapon_f.attack(fighter.name)
    weapon_m.attack(monster.name)

    # Определение победителя по эффективности выбранного оружия
    if weapon_f.effect > weapon_m.effect:
        print("Монстр побеждён!!!")
        break
    elif weapon_f.effect < weapon_m.effect:
        print("Увы, Монстр оказался сильнее.")
        break
    else:
        print("Бой продолжается")

    time.sleep(5)                                       # Задержка между схватками
